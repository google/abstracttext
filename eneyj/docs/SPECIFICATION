== Specification of eneyj ==

1) Z1 ZObject

1.1) Everything is a ZObject.
     ZObjects are the only data structure.
     Code and data are both represented as ZObjects.
     ZObjects are also called eneyj objects.

1.2) ZObjects are immutable.

1.3) ZObjects are sets of key-value pairs.

1.4) Keys of key-value pairs of ZObjects are either global or local.

1.5) Global keys have the form ZnKn with n natural numbers.

1.6) Local keys have the form Kn with n consecutive natural numbers.

1.7) Every key on a ZObject must be unique.

1.8) Values of key-value pairs of all ZObjects must be ZObjects.

1.9) Every ZObject must have a key Z1K1 Type.

2) Normal JSON serialization

2.1) Every ZObject is serializable as a JSON object.

2.2) The normal serialization results in valid JSON per IETF RFC 7159.

2.3) Every eneyj implementation must support reading the normal JSON
     serialization.

2.4) Every eneyj implementation may support other serializations. Other
     serializations will often be more compact or have other advantages.

2.5) The normal JSON serialization serializes a single ZObject as a single
     JSON Object.

2.6) A single JSON file contains a single ZObject.

2.7) The keys are sorted alphabetically for the letters and numerically for the
     number parts of the keys.

2.8) If the key is Z1K2 Id or Z6K1 Stringvalue the value is always
     serialized as a simple string.

2.9) All other values are serialized as JSON objects using normal serialization.

3) Canonical JSON serialization

3.1) The Canonical JSON serialization is a more compact serialization, that is
     easier to read and write for humans.

3.2) The Canonical JSON serialization is the one used for Wikilambda and the
     reference implementation for storing ZObjects.

3.3) An eneyj implementation should be able to read the Canonical serialization.

3.4) If an eneyj implementation writes ZObjects out, it must support either the
     Normal or the Canonical serialization, or both.

3.5) Z9 References are written as simple string values instead of full-fledged
     ZObjects.

3.6) Z1K2 Id and Z6K1 Stringvalue is always written as a simple string value.

3.7) Z6 Strings are written as ZObjects if they start with a capital letter
     followed with a digit (unless they are on Z1K2 or Z6K1 keys).
     Otherwise they are written as simple string values.

3.8) A Z10 List is serialized as an Array in the JSON serialization.
     This is skipped if the Z10 List has any keys besides Z10K1 Head and
     Z10K2 Tail.

4) ID

4.1) A ZObject that is being persisted must have a Z1K2 ID.

4.2) The Z1K2 ID is used to refer to the ZObject.

4.3) Z1K2 IDs must be unique.
     Two different ZObjects must not have the same Z1K2 ID.
     Two ZObjects that are equal may have two different ZIDs, though.

4.4) The Z1K2 ID has the form Zn or ZnKn with n natural numbers.

4.5) Two ZObjects with the same Z1K2 ID must be equal.
     This is modulo QA procedures, namespaces, caching, and metadata.

4.6) A ZObject that is not persisted does not have a Z1K2 ID.
     These are called transient ZObjects.

5) Validation

5.1) Every ZObject that fulfills the conditions in Section 1 is a
     well-formed ZObject.

5.2) A well-formed ZObject gets validated by running the Z4K3 validator
     function of its Z1K1 type against itself.

5.3) A validator function is a function that takes a single parameter, the
     instance, and returns a list of Z5 errors.

5.4) A well-formed ZObject that returns an empty list when running the
     validator is a valid instance of its type and a valid ZObject.

6) Evaluation

6.1) All Z7 function calls in a valid ZObject get evaluated.

6.2) The evaluation result in turn gets validated and evaluated again.

6.3) This stops when a fix point is reached, i.e. the result of the evaluation
     is the same as its argument.

6.4) Evaluating a function happens by the evaluator choosing an implementation,
     replacing the function with that, and then executing the implementation.

6.5) All arguments are passed unevaluated to the evaluator.
     Each implementation decides when and if to evaluate any of the arguments.
     Full evaluation may not be assumed, i.e. lazy evaluations are allowed.

7) Z4 Type

7.1) Every Z1 ZObject has a Z1K1 type of type Z4.

7.2) The type system is strict and nominal.

7.3) There is no type hierarchy.
     That makes Z1 being an instance of Z4 Type be a slight misnomer.

7.4) A type has a key Z4K3 validator which is a function that validates an
     instance of a type.

7.5) If the Z1K1 points to a function call, the function call needs to be
     evaluated in order to get the Z4 object back.
     The result of the evaluation is the type.

8) Z5 Error

8.1) Errors are raised for locally unresolvable situations.

8.2) A function can choose to handle an error, but has to state that it
     will do so explictly in its signature, i.e. in its
     Z17 argument declaration.

8.3) If a function does not explicate that it will handle an error, the error
     gets automatically wrapped and raised.

9) Z8 Function

9.1) All functions are marked as either pure or unpure.

9.2) Pure functions must not call unpure functions.

9.3) Pure functions can be replaced by the resulting value without reevaluation.

9.4) Unpure functions might be marked with a caching policy.

9.5) A function can have more than one implementation.

9.6) All implementations should return the same results for all inputs.
     All implementations have to strictly follow the function definition.

9.7) An evaluator can choose which implementation to use to evaluate a function.

10) Z9 Reference

10.1) A reference to a ZObject is a standin for the ZObject with the same ZID.

10.2) A reference can be replaced by the ZObject at any time.

== Notes ==

The specification above should capture the core of eneyj.
The following describe several patterns in a more prose way and also some of
the tooling around the core.

=== REPL ===

The REPL, or the command line interface, takes an input string.
It then runs a function over that input string which parses and
preprocesses the input and returns a ZObject.
That ZObject gets validated by the validator of the type of the ZObject.
If valid, the result then evaluates until it reaches a fix point.
Then the REPL calls a function to linearize the resulting ZObject to a string.
This string is then displayed to the user and the REPL ask for new input.

This follows the definition of REPL: Read, Evaluate, Print, Loop.

A good REPL should allow to:
- set the parsing function
- switch the validation step on or off
- switch evaluation on or off
- set the linearization function

This allows for many interesting patterns.
For example, there could be parser for many different syntaxes.
Simple function call syntaxes, a Haskell-like syntax without many brackets,
a syntax that is closer to mathematics, translations from labels to ZIDs,
or completely domain specific syntaxes.
The parser can then also include a preprocessor.
One example of preprocessing is to automatically add type coercions,
thus making it easier to write function calls.
One interesting preprocessor step is to replace a function with an
implementation, and thus force the evaluator to use a specific implementation.
Also the linearizer can be highly flexible towards a given use case.
Parsers and linearizers will be functions in Wikilambda, which will allow
anyone to create new parsers and linearizers and thus introduce interesting
usage patterns.

=== Types ===

A type contains a list of keys which are usually the keys that objects of this
type will have.
But the true arbiter of whether an object is valid or not is the validation
function that is part of the type.
This allows to add generic types by having functions that return a type with
custom keys and a custom validation function.

For example, if we want to have a list of strings as a type, we can call
a function "list" that takes as a parameter a type and returns a type, and
if we called it with "list(string)" it will return a type that has a validator
that ensures that an object fulfills all the conditions of a list and
additionally that each element of the list is of type string.

In order to allow for type checking to work, all types have a key that
quotes the function call that created the type.

=== Function calls ===

A function call is evaluated by executing an implementation as chosen by the
evaluator in the preprocessing step.
All implementations should always evaluate to the same result so the chosen
implementation should not matter, modulo run-time behaviour.
Implementations are objects of their own.

=== Z14 Implementations ===

A function can have several implementations associated with it.
Every implementation must strictly follow the the specification of the function.
All implementations of a function must return the same results for the same
input if they are functional.

Implementations can be given as built-ins (we hope to keep the numbers low)
and the evaluator in that case has to be able to evalute those natively,
or in written in a programming language the evaluator supports, or implemented
by composition of other functions.

=== Errors ===

An error is an object of type error(error_type).
I.e. the error function takes an error type object as the parameter and returns
a type.
The object has further keys, as specified by the error type, in order to keep
useful information about the error.

Example: if you call the division function with a zero for the denominator,
you could get the following object back:
> divide(four, zero)
error(division_by_zero)(four)

=== Mapping of ID characters throughout Wikidata and Wikilambda ===

B - Bad objects (with errors, only for testing)
C ? Implementation / Code (Z) (should be Z, will be dropped)
E - Entity shapes (Wikidata)
F - Form (L)
K - Key (Z)
L - Lexeme (Wikidata)
M - Media File (Commons) (?)
T ? Test (Z Function) (should be Z, will be dropped)
P - Property (Wikidata)
Q - Item (Wikidata)
S - Sense (L)
Z - ZObject (Wikilambda)
